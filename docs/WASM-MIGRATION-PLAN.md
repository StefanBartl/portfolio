# Fighting Game: JavaScript â†’ C++/WASM Migration Plan

## Table of content

- [Fighting Game: JavaScript â†’ C++/WASM Migration Plan](#fighting-game-javascript-cwasm-migration-plan)
  - [Current Status: JavaScript (TypeScript)](#current-status-javascript-typescript)
  - [Migration Goals](#migration-goals)
  - [Phase 1: Preparation (Week 1-2)](#phase-1-preparation-week-1-2)
    - [âœ… Tasks Completed](#tasks-completed)
    - [ðŸ”² Remaining Tasks](#remaining-tasks)
    - [Tools Needed](#tools-needed)
- [Install Emscripten](#install-emscripten)
  - [Phase 2: Core Game Logic (Week 3-4)](#phase-2-core-game-logic-week-3-4)
    - [C++ Implementation Structure](#c-implementation-structure)
    - [WASM Bindings (Embind)](#wasm-bindings-embind)
    - [Build Configuration](#build-configuration)
- [CMakeLists.txt](#cmakeliststxt)
  - [Phase 3: Integration (Week 5)](#phase-3-integration-week-5)
    - [TypeScript Wrapper](#typescript-wrapper)
    - [React Component Update](#react-component-update)
  - [Phase 4: Optimization (Week 6)](#phase-4-optimization-week-6)
    - [Performance Targets](#performance-targets)
    - [Optimization Techniques](#optimization-techniques)
  - [Testing Checklist](#testing-checklist)
  - [Rollout Strategy](#rollout-strategy)
  - [Fallback Plan](#fallback-plan)
  - [Resources](#resources)
  - [Next Steps](#next-steps)

---

## Current Status: JavaScript (TypeScript)

The fighting game is currently implemented in TypeScript with the following architecture:

```
src/components/game/
â”œâ”€â”€ classes.ts          # Game entities and logic
â””â”€â”€ FightingGame.tsx    # React wrapper and UI
```

## Migration Goals

1. **Performance**: Achieve consistent 60fps with complex game logic
2. **Learning**: Demonstrate C++/WASM skills in portfolio
3. **Modularity**: Keep JavaScript for UI, move logic to WASM

## Phase 1: Preparation (Week 1-2)

### âœ… Tasks Completed
- [x] TypeScript conversion
- [x] Type safety for all game entities
- [x] Clear separation of logic and rendering

### ðŸ”² Remaining Tasks
- [ ] Set up C++ build environment
- [ ] Install Emscripten SDK
- [ ] Create CMake project structure
- [ ] Write initial C++ game loop

### Tools Needed
```bash
# Install Emscripten
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
```

## Phase 2: Core Game Logic (Week 3-4)

### C++ Implementation Structure

```cpp
// game_engine.h
class Fighter {
public:
    Fighter(float x, float y);
    void update(float deltaTime);
    void attack();
    void takeHit(int damage);

    // Getters for JS bindings
    float getX() const;
    float getY() const;
    int getHealth() const;
    bool isAttacking() const;

private:
    float x, y;
    float velocityX, velocityY;
    int health;
    bool attacking;
};

class GameEngine {
public:
    GameEngine();
    void update(float deltaTime);
    bool checkCollision(const Fighter& f1, const Fighter& f2);

private:
    Fighter player;
    Fighter enemy;
};
```

### WASM Bindings (Embind)

```cpp
// bindings.cpp
#include <emscripten/bind.h>
#include "game_engine.h"

using namespace emscripten;

EMSCRIPTEN_BINDINGS(game_module) {
    class_<Fighter>("Fighter")
        .constructor<float, float>()
        .function("update", &Fighter::update)
        .function("attack", &Fighter::attack)
        .function("takeHit", &Fighter::takeHit)
        .property("x", &Fighter::getX)
        .property("y", &Fighter::getY)
        .property("health", &Fighter::getHealth)
        .property("isAttacking", &Fighter::isAttacking);

    class_<GameEngine>("GameEngine")
        .constructor<>()
        .function("update", &GameEngine::update)
        .function("checkCollision", &GameEngine::checkCollision);
}
```

### Build Configuration

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(FightingGameWASM)

set(CMAKE_CXX_STANDARD 17)

add_executable(game
    src/game_engine.cpp
    src/fighter.cpp
    src/bindings.cpp
)

set_target_properties(game PROPERTIES
    COMPILE_FLAGS "-O3 -s WASM=1"
    LINK_FLAGS "-s WASM=1 -s ALLOW_MEMORY_GROWTH=1 --bind"
    SUFFIX ".wasm"
)
```

## Phase 3: Integration (Week 5)

### TypeScript Wrapper

```typescript
// game-wasm.ts
import GameModule from './game.js'; // Generated by Emscripten

let wasmModule: any = null;

export async function initGame() {
    wasmModule = await GameModule();
    return wasmModule;
}

export class WasmFighter {
    private fighter: any;

    constructor(x: number, y: number) {
        if (!wasmModule) throw new Error('WASM not initialized');
        this.fighter = new wasmModule.Fighter(x, y);
    }

    update(deltaTime: number) {
        this.fighter.update(deltaTime);
    }

    get x() { return this.fighter.x; }
    get y() { return this.fighter.y; }
    get health() { return this.fighter.health; }
}
```

### React Component Update

```tsx
// FightingGameWasm.tsx
import { useEffect, useState } from 'react';
import { initGame, WasmFighter } from './game-wasm';

export default function FightingGameWasm() {
    const [wasmReady, setWasmReady] = useState(false);

    useEffect(() => {
        initGame().then(() => {
            setWasmReady(true);
        });
    }, []);

    if (!wasmReady) {
        return <div>Loading WASM module...</div>;
    }

    // ... rest of component using WasmFighter
}
```

## Phase 4: Optimization (Week 6)

### Performance Targets

- [ ] Maintain 60fps with 100+ game objects
- [ ] WASM module size < 500KB (compressed)
- [ ] Loading time < 1 second

### Optimization Techniques

1. **Memory Management**
   ```cpp
   // Use object pools to avoid allocations
   class FighterPool {
       std::vector<Fighter> pool;
   public:
       Fighter* acquire();
       void release(Fighter* f);
   };
   ```

2. **SIMD Instructions**
   ```cpp
   // Use Emscripten SIMD support
   #include <wasm_simd128.h>
   // Vectorize collision detection
   ```

3. **Build Optimization**
   ```bash
   emcc -O3 -s WASM=1 \
        -s ALLOW_MEMORY_GROWTH=1 \
        -s INITIAL_MEMORY=16MB \
        --closure 1 \
        game.cpp -o game.js
   ```

## Testing Checklist

- [ ] Unit tests for C++ game logic
- [ ] Integration tests for WASM bindings
- [ ] Performance benchmarks (JS vs WASM)
- [ ] Browser compatibility (Chrome, Firefox, Safari)
- [ ] Mobile device testing

## Rollout Strategy

1. **Feature Flag**: Keep both versions, toggle via config
2. **Gradual Rollout**: Start with 10% of traffic
3. **Monitor Metrics**:
   - Frame rate
   - Loading time
   - Error rate
4. **Full Migration**: After 1 week of stable operation

## Fallback Plan

If WASM performance is worse than JS:
- Keep JS version as default
- Offer WASM as "experimental feature"
- Continue optimizing C++ code

## Resources

- [Emscripten Documentation](https://emscripten.org/docs/)
- [WebAssembly.org](https://webassembly.org/)
- [Embind Examples](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html)
- [WASM Game Dev](https://github.com/WebAssembly/game-dev)

## Next Steps

1. Set up development environment
2. Implement Fighter class in C++
3. Create simple collision detection
4. Build with Emscripten
5. Test basic integration
6. Iterate and optimize

---

**Note**: Keep detailed performance metrics at each phase to justify the migration!
